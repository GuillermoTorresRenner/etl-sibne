import fs from 'fs/promises';
import path from 'path';
import pkg from 'pg';
import sql from 'mssql';
import 'dotenv/config';

const { Client } = pkg;

// Configuraciones
const sqlServerConfig = {
  server: 'localhost',
  port: 1433,
  database: 'SIBNE_ETL',
  user: 'sa',
  password: '4Emperador*',
  pool: {
    max: 10,
    min: 0,
    idleTimeoutMillis: 30000
  },
  options: {
    encrypt: false,
    trustServerCertificate: true
  }
};

const postgresConfig = {
  host: 'localhost',
  port: 5432,
  database: 'sibne',
  user: 'sibne',
  password: 'D3vel0p3rM0deP4SS'
};

/**
 * Migra metadatos de ArchivoAdjunto usando archivos previamente extra√≠dos
 */
class ArchivoAdjuntoMigrator {
  constructor() {
    this.extractedFilesReport = null;
  }

  /**
   * Carga el reporte de archivos extra√≠dos
   */
  async loadExtractedFilesReport() {
    try {
      const reportPath = path.join(process.cwd(), 'extracted-files-report.json');
      const reportData = await fs.readFile(reportPath, 'utf8');
      this.extractedFilesReport = JSON.parse(reportData);
      console.log(`‚úÖ Cargado reporte de ${this.extractedFilesReport.length} archivos extra√≠dos`);
    } catch (error) {
      console.error('‚ùå Error cargando reporte de archivos extra√≠dos:', error);
      throw error;
    }
  }

  /**
   * Migra metadatos de ArchivoAdjunto a PostgreSQL
   */
  async migrateArchivoAdjunto() {
    let sqlPool, pgClient;

    try {
      // Cargar reporte de archivos extra√≠dos
      await this.loadExtractedFilesReport();

      // Conectar a SQL Server
      sqlPool = await sql.connect(sqlServerConfig);
      console.log('‚úÖ Conectado a SQL Server');

      // Conectar a PostgreSQL
      pgClient = new Client(postgresConfig);
      await pgClient.connect();
      console.log('‚úÖ Conectado a PostgreSQL');

      // Obtener metadatos de SQL Server
      const sqlResult = await sqlPool.request().query(`
        SELECT Id, NombreArchivo, Tipo, Ext
        FROM ArchivoAdjunto
        WHERE FileData IS NOT NULL
        ORDER BY Id
      `);

      console.log(`üìä Encontrados ${sqlResult.recordset.length} registros en SQL Server`);

      // Crear mapeo entre IDs originales y archivos extra√≠dos
      const fileMap = new Map();
      this.extractedFilesReport.forEach(file => {
        fileMap.set(file.originalId, file);
      });

      let insertedCount = 0;
      let skippedCount = 0;

      // Migrar cada registro
      for (const record of sqlResult.recordset) {
        const { Id, NombreArchivo, Tipo, Ext } = record;
        const extraccionFileInfo = fileMap.get(Id);

        if (!extraccionFileInfo) {
          console.log(`‚ö†Ô∏è  Archivo ID ${Id} no encontrado en archivos extra√≠dos, saltando...`);
          skippedCount++;
          continue;
        }

        try {
          // Insertar en PostgreSQL con referencia al archivo extra√≠do en schema dbo
          const insertQuery = `
            INSERT INTO dbo."ArchivoAdjunto" (
              "Id", 
              "NombreArchivo", 
              "Tipo", 
              "Ext", 
              "Location", 
              "NanoId", 
              "RutaRelativa"
            ) VALUES ($1, $2, $3, $4, $5, $6, $7)
            ON CONFLICT ("Id") DO UPDATE SET
              "NombreArchivo" = EXCLUDED."NombreArchivo",
              "Tipo" = EXCLUDED."Tipo",
              "Ext" = EXCLUDED."Ext",
              "Location" = EXCLUDED."Location",
              "NanoId" = EXCLUDED."NanoId",
              "RutaRelativa" = EXCLUDED."RutaRelativa"
          `;

          await pgClient.query(insertQuery, [
            Id,
            NombreArchivo,
            Tipo,
            Ext,
            extraccionFileInfo.location,
            extraccionFileInfo.nanoId,
            extraccionFileInfo.relativePath
          ]);

          insertedCount++;
          console.log(`‚úÖ Migrado: ${NombreArchivo} (ID: ${Id}) ‚Üí ${extraccionFileInfo.fileName}`);

        } catch (insertError) {
          console.error(`‚ùå Error insertando registro ID ${Id}:`, insertError);
          skippedCount++;
        }
      }

      console.log('\nüìä RESUMEN DE MIGRACI√ìN:');
      console.log(`‚úÖ Registros migrados: ${insertedCount}`);
      console.log(`‚ö†Ô∏è  Registros saltados: ${skippedCount}`);
      console.log(`üìÅ Total en SQL Server: ${sqlResult.recordset.length}`);

      return {
        success: true,
        inserted: insertedCount,
        skipped: skippedCount,
        total: sqlResult.recordset.length
      };

    } catch (error) {
      console.error('‚ùå Error en migraci√≥n de ArchivoAdjunto:', error);
      throw error;
    } finally {
      if (sqlPool) {
        await sqlPool.close();
        console.log('‚úÖ Conexi√≥n SQL Server cerrada');
      }
      if (pgClient) {
        await pgClient.end();
        console.log('‚úÖ Conexi√≥n PostgreSQL cerrada');
      }
    }
  }

  /**
   * Verifica la migraci√≥n
   */
  async verifyMigration() {
    let pgClient;

    try {
      pgClient = new Client(postgresConfig);
      await pgClient.connect();

      // Contar registros en PostgreSQL (schema dbo)
      const countResult = await pgClient.query('SELECT COUNT(*) as count FROM dbo."ArchivoAdjunto"');
      const pgCount = parseInt(countResult.rows[0].count);

      // Verificar que todos tengan Location
      const locationResult = await pgClient.query('SELECT COUNT(*) as count FROM dbo."ArchivoAdjunto" WHERE "Location" IS NOT NULL');
      const withLocationCount = parseInt(locationResult.rows[0].count);

      console.log('\nüìã VERIFICACI√ìN DE MIGRACI√ìN:');
      console.log(`üìä Total registros en PostgreSQL: ${pgCount}`);
      console.log(`üìÅ Registros con Location: ${withLocationCount}`);

      if (pgCount === withLocationCount) {
        console.log('‚úÖ Todos los registros tienen Location asignado');
      } else {
        console.log(`‚ö†Ô∏è  ${pgCount - withLocationCount} registros sin Location`);
      }

      return {
        totalRecords: pgCount,
        withLocation: withLocationCount,
        success: pgCount === withLocationCount
      };

    } catch (error) {
      console.error('‚ùå Error verificando migraci√≥n:', error);
      throw error;
    } finally {
      if (pgClient) {
        await pgClient.end();
      }
    }
  }
}

// Funci√≥n principal
async function main() {
  console.log('üöÄ INICIANDO MIGRACI√ìN DE METADATOS DE ARCHIVOS');
  console.log('='.repeat(50));
  
  try {
    const migrator = new ArchivoAdjuntoMigrator();
    
    // Ejecutar migraci√≥n
    const result = await migrator.migrateArchivoAdjunto();
    
    if (result.success) {
      // Verificar migraci√≥n
      await migrator.verifyMigration();
      console.log('\n‚úÖ MIGRACI√ìN COMPLETADA EXITOSAMENTE');
    }
    
  } catch (error) {
    console.error('‚ùå Error en la migraci√≥n:', error);
    process.exit(1);
  }
}

// Ejecutar script
main();